gbaemu4ds original code that must be resolved for TGDS port to happen:

[main codebase; branch:alpha2fix5-arm9irqs-fixed+fireredgreenleaffixed-03092016_NEWMODE1-gitd.zip]
- firered version (sound) is codebase (new save method already applied), but...
[branch:gbaemu4DS-ancient-correct-mode0-gitd.zip]
- merge ancient branch mode0 fix into firered version (through a #ifdef template so we can change between mode0/mode1)

- merge branches into main codebase: 
[branch:28092017-gbaemu4ds-newhwirq-stable-sleepmode-vcountirqfailing_NEWMODE1-gitd.zip]
[branch:28092017-alpha2fix5_dmalogicnew_9112016_newsave_NEWMODE1-gitd.zip]


TGDS port:
- remove all printf
- add new irqs from tgds to gbaemu4ds
- use old libfat


Coto:
27/04/2018


notes:

using swi code


swi:
inter_swi:
@change the PU to nds mode
ldr	SP,=0x36333333	
mcr	p15, 0, SP, c5, c0, 2	

@ save the GBA frame context
ldr	r12, =exRegs
stmia	r12, {r0-r11}	@lr is GBA PC
str lr, [r12,#(4*15)]

@ restore nds swi stack context
ldr	sp, =__sp_svc
@ldr sp,[sp]	@could cause bugs

@coto: gba mode spsr to define what offset of swi we need.
mrs r0,spsr

@ jump into the personal handler
ldr	r1, =exHandlerswi
ldr	r1, [r1]	
blx	r1

@save nds swi stack context
ldr	r1, =__sp_svc
@ldr r1,[r1]	@could cause bugs
str sp, [r1]	

@restore the GBA frame context (this LR is reusable, r13 no because we need to restore it and r15 is the on-exit frame address) 
ldr	lr, =exRegs
ldmia	lr, {r0-r11}
ldr sp,[lr,#(4*13)]	@coto: yeah this means another instruction but even if upcoming PSR swap stacks we maintain original stack in future SPSR 
ldr lr,[lr,#(4*15)]
MOVS PC,LR			@GBA PC is next NDS PC
@code ok
@---- swi end

this is bugged, cause games to segfault/loop



--